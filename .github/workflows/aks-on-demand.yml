name: AKS On-Demand Pipeline

on:
  push:
    branches:
      - main
  workflow_dispatch:
    inputs:
      action:
        description: 'Terraform action to perform (apply/destroy)'
        required: true
        default: 'apply'
        type: choice
        options:
          - apply
          - destroy

jobs:
  aks-terraform:
    runs-on: ubuntu-latest
    env:
      TFSTATE_RESOURCE_GROUP: ${{ secrets.TFSTATE_RESOURCE_GROUP }}
      TFSTATE_STORAGE_ACCOUNT: ${{ secrets.TFSTATE_STORAGE_ACCOUNT }}
      TFSTATE_CONTAINER: ${{ secrets.TFSTATE_CONTAINER }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}
      - name: Set up Terraform
        uses: hashicorp/setup-terraform@v3
      - name: Create terraform.tfvars
        run: |
          cat <<EOF > JIT/jit-se-testing/az-aks-nodejs-app01/aks/terraform.tfvars
          tfstate_resource_group = "${TFSTATE_RESOURCE_GROUP}"
          tfstate_storage_account = "${TFSTATE_STORAGE_ACCOUNT}"
          tfstate_container = "${TFSTATE_CONTAINER}"
          resource_group_name = "jit-se-testing-aks-rg"
          location = "West Europe"
          cluster_name = "jit-se-testing-aks01"
          dns_prefix = "jit-se-testing-aks01"
          node_count = 1
          vm_size = "Standard_DS2_v2"
          public_ip_name = "jit-se-testing-aks-public-ip"
          EOF
      - name: Terraform Init (with remote backend)
        working-directory: JIT/jit-se-testing/az-aks-nodejs-app01/aks
        run: |
          terraform init \
            -backend-config="resource_group_name=$TFSTATE_RESOURCE_GROUP" \
            -backend-config="storage_account_name=$TFSTATE_STORAGE_ACCOUNT" \
            -backend-config="container_name=$TFSTATE_CONTAINER" \
            -backend-config="key=aks-public.terraform.tfstate"
      - name: Terraform Plan
        working-directory: JIT/jit-se-testing/az-aks-nodejs-app01/aks
        run: terraform plan
      - name: Terraform Apply
        if: github.event_name == 'push' || (github.event_name == 'workflow_dispatch' && github.event.inputs.action == 'apply')
        working-directory: JIT/jit-se-testing/az-aks-nodejs-app01/aks
        run: terraform apply -auto-approve
      - name: Print kubeconfig
        if: github.event_name == 'push' || (github.event_name == 'workflow_dispatch' && github.event.inputs.action == 'apply')
        working-directory: JIT/jit-se-testing/az-aks-nodejs-app01/aks
        run: |
          echo "Kubeconfig output:"
          terraform output kube_config
      - name: Print public IP
        if: github.event_name == 'push' || (github.event_name == 'workflow_dispatch' && github.event.inputs.action == 'apply')
        working-directory: JIT/jit-se-testing/az-aks-nodejs-app01/aks
        run: |
          echo "Public IP address:"
          terraform output aks_public_ip
      - name: Get AKS credentials and check public IP
        if: github.event_name == 'push' || (github.event_name == 'workflow_dispatch' && github.event.inputs.action == 'apply')
        run: |
          # Get AKS credentials
          az aks get-credentials --resource-group $(terraform -chdir=JIT/jit-se-testing/az-aks-nodejs-app01/aks output -raw resource_group_name) --name $(terraform -chdir=JIT/jit-se-testing/az-aks-nodejs-app01/aks output -raw aks_cluster_name) --overwrite-existing
          
          echo "AKS cluster is ready!"
          echo "To deploy your application and get the public IP:"
          echo "1. Deploy your application: kubectl apply -f manifests/"
          echo "2. Check the service: kubectl get service -o wide"
          echo "3. The EXTERNAL-IP will show your public IP for port 3000"
      - name: Terraform Destroy
        if: github.event_name == 'workflow_dispatch' && github.event.inputs.action == 'destroy'
        working-directory: JIT/jit-se-testing/az-aks-nodejs-app01/aks
        run: terraform destroy -auto-approve
 